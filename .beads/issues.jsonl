{"id":"cw-5p3","title":"Implement output formatter interface and implementations","description":"## Design Reference\n@docs/design.md#output-formatter-internalformat\n@docs/design.md#streamjson-formatter\n@docs/design.md#text-formatter\n\n## Context\nReplaces the direct forwardToStdout function with a pluggable Formatter interface. The orchestrator calls the formatter for each event instead of writing raw bytes. Two implementations: streamJSON (byte-identical passthrough) and text (human-readable rendering). The text formatter depends on content event types from internal/events/.\n\n## Requirements\n- [ ] Define Formatter interface with WriteEvent, WriteHangIndicator, Flush methods\n- [ ] Implement New(format string, w io.Writer) Formatter factory function\n- [ ] Implement streamJSON formatter: WriteEvent writes raw JSON + newline, WriteHangIndicator writes synthetic wrapper/hang_detected JSON event, Flush is no-op\n- [ ] Implement text formatter: WriteEvent dispatches on event type/subtype per rendering rules table\n- [ ] Text rendering: assistant events print message text, tool_call/started prints spinner + command, tool_call/completed prints checkmark/cross + timing, thinking and system events are silent\n- [ ] Text WriteHangIndicator prints human-readable warning line\n- [ ] Text Flush writes blank line to separate turns\n- [ ] Text formatter handles parse failures gracefully (log at debug, skip event, no crash)\n\n## Technical Approach\n- Files to create: internal/format/format.go, internal/format/streamjson.go, internal/format/text.go, internal/format/format_test.go\n- streamJSON.WriteEvent: f.w.Write(ev.Raw) + f.w.Write([]byte(\"\\n\"))\n- streamJSON.WriteHangIndicator: fmt.Sprintf with synthetic JSON containing reason.String()\n- text.WriteEvent: switch on ev.Parsed.Type/Subtype, call ParseAssistantMessage/ParseToolCallInfo/ParseShellToolResult from events package for content extraction\n- text struct holds only io.Writer (no state needed for current rendering rules)\n- Shell tool_call/completed rendering: extract executionTime for display as seconds, exitCode for check/cross\n- New() panics on unknown format name (caller validates before calling)\n- Dependencies: task cw-fjr.2 (events — needs AnnotatedEvent, content parse functions), task cw-fjr.5 (monitor — needs monitor.Reason for WriteHangIndicator)\n\n## Verification\n- [ ] Unit tests: streamJSON WriteEvent outputs raw bytes + newline, byte-identical to input\n- [ ] Unit tests: streamJSON WriteHangIndicator outputs valid JSON with type/subtype/message\n- [ ] Unit tests: text assistant events render message text\n- [ ] Unit tests: text tool_call/started (shell) renders spinner + command\n- [ ] Unit tests: text tool_call/started (non-shell) renders spinner + toolType\n- [ ] Unit tests: text tool_call/completed (exit 0) renders checkmark + timing\n- [ ] Unit tests: text tool_call/completed (exit non-zero) renders cross + timing\n- [ ] Unit tests: text thinking/delta events produce no output\n- [ ] Unit tests: text system/init, user, result events produce no output\n- [ ] Unit tests: text parse failures in content types are handled gracefully (no panic, no output)\n- [ ] Unit tests: text WriteHangIndicator renders warning with reason summary\n- [ ] Unit tests: text Flush writes blank line\n- [ ] `go vet ./internal/format/...` passes\n\n## Acceptance Criteria\nSubset: AC #8 (stream-json byte-identical passthrough), AC #13 (text format human-readable rendering)\n\n## Parallelization\nDepends on events (cw-fjr.2) and monitor (cw-fjr.5). Can be worked alongside logger (cw-fjr.4).","status":"open","priority":0,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T12:38:20.582082-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:38:20.582082-06:00","dependencies":[{"issue_id":"cw-5p3","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T12:39:12.417351-06:00","created_by":"Travis Brown"},{"issue_id":"cw-5p3","depends_on_id":"cw-fjr.2","type":"blocks","created_at":"2026-02-11T12:39:17.141221-06:00","created_by":"Travis Brown"},{"issue_id":"cw-5p3","depends_on_id":"cw-fjr.5","type":"blocks","created_at":"2026-02-11T12:39:17.241302-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr","title":"cursor-agent hang detection wrapper","description":"## Design Document\n@docs/design.md\n\n## Overview\nBuild a Go CLI wrapper (`cursor-wrap`) around the `cursor-agent` CLI that:\n- Transparently proxies stream-json output (or renders human-readable text)\n- Detects hangs by analyzing event flow patterns in real time\n- Takes corrective action (kill + recovery) when a hang is confirmed\n- Produces structured logs sufficient for post-mortem analysis\n- Supports both single-shot (`-p`) and interactive multi-turn usage with `--resume`\n\n## Packages\n- `cmd/cursor-wrap/` — CLI entry point, flag parsing, session loop, per-turn event loop\n- `internal/events/` — JSON event types (base + content), streaming parser\n- `internal/format/` — Output formatting: stream-json passthrough, human-readable text\n- `internal/monitor/` — Hang detection state machine\n- `internal/process/` — Child process spawn (with `--resume`), kill, wait\n- `internal/logger/` — Dual-sink structured logging (JSONL file + console) via LogSession wrapper\n\n## Acceptance Criteria\n1. Wrapper exits 0 when cursor-agent completes normally (result event received)\n2. Wrapper detects an idle hang (no events, no open tools) within idleTimeout + tickInterval and exits non-zero\n3. Wrapper detects a tool-timeout hang (tool exceeds declared timeout + grace) within toolGrace + tickInterval and exits non-zero\n4. Wrapper does NOT false-positive on a long-running tool call that is within its declared timeout\n5. Wrapper does NOT false-positive on parallel tool calls where one finishes before others\n6. Every raw cursor-agent event appears in the log file with a recv_ts\n7. Every hang detection decision appears in the log file with the full Reason struct\n8. With --output-format stream-json, cursor-agent events on wrapper stdout are byte-identical to cursor-agent stdout (transparent proxy). The only addition is the synthetic wrapper/hang_detected event from WriteHangIndicator in interactive mode after a hang kill.\n9. On SIGINT/SIGTERM to the wrapper, the child process is killed cleanly\n10. All thresholds are configurable via CLI flags\n11. In interactive mode, the wrapper reads subsequent prompts from stdin and resumes the cursor-agent session via --resume \u003csession_id\u003e\n12. In interactive mode, hang detection kills the current turn's process and prompts for the next input (does not exit the wrapper)\n13. With --output-format text, assistant text and tool call status are rendered in human-readable form\n14. -p flag runs a single turn and exits; omitting -p enters the interactive multi-turn loop","status":"open","priority":0,"issue_type":"epic","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:08:13.774782-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:34:36.891193-06:00"}
{"id":"cw-fjr.1","title":"Initialize Go module and project directory structure","description":"## Design Reference\n@docs/design.md#architecture\n@docs/coding-standards.md#project-layout\n\n## Context\nFoundation task. Creates the Go module and directory skeleton that all other tasks build on. No business logic — just the structural scaffolding.\n\n## Requirements\n- [ ] Create go.mod with appropriate module path\n- [ ] Create directory structure: cmd/cursor-wrap/, internal/events/, internal/format/, internal/monitor/, internal/process/, internal/logger/\n- [ ] Create minimal main.go placeholder in cmd/cursor-wrap/\n- [ ] Update .gitignore for Go binary artifacts\n- [ ] Verify `go build ./...` succeeds\n\n## Technical Approach\n- Module path: `cursor-wrap` (no remote import path needed — everything is internal)\n- Go version: 1.25 (matches local toolchain)\n- main.go: minimal placeholder that compiles, e.g. prints version and exits\n- Files to create: go.mod, cmd/cursor-wrap/main.go\n- Directories to create: internal/events/, internal/format/, internal/monitor/, internal/process/, internal/logger/\n- Dependencies: none (first task)\n\n## Verification\n- [ ] `go build ./cmd/cursor-wrap` compiles without errors\n- [ ] `go vet ./...` passes\n- [ ] Directory structure matches coding-standards.md layout (including internal/format/)\n\n## Acceptance Criteria\nSubset: none directly — this is scaffolding that enables all other acceptance criteria.\n\n## Parallelization\nNo dependencies. This must complete before all other tasks.","status":"closed","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:08:43.488711-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:55:28.622742-06:00","closed_at":"2026-02-11T12:55:28.622742-06:00","close_reason":"Closed","dependencies":[{"issue_id":"cw-fjr.1","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:08:43.48934-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.2","title":"Implement event types and streaming parser","description":"## Design Reference\n@docs/design.md#data-model\n@docs/design.md#content-event-types-for-output-formatter\n@docs/design.md#event-reader-internalevents\n@docs/stream-json-events.md\n\n## Context\nDefines the Go types for all cursor-agent stream-json events and implements the streaming Reader that parses stdout line-by-line into typed AnnotatedEvents. This is consumed by the monitor (for hang detection), the orchestrator (for logging and forwarding), and the text formatter (for rendering). Includes both base event types (for the monitor) and content event types (for the text formatter).\n\n## Requirements\n- [ ] Define RawEvent struct with Type, Subtype, Line fields\n- [ ] Define AnnotatedEvent struct wrapping RawEvent with RecvTime and Raw bytes\n- [ ] Define SystemInit, ToolCallStarted, ToolCallCompleted, Result structs\n- [ ] Define ShellToolArgs struct for extracting timeout/command from shellToolCall\n- [ ] Define content event types: AssistantMessage, ThinkingDelta, ToolCallInfo, ShellToolResult\n- [ ] Implement ParseAssistantMessage(raw []byte) — extracts text from assistant event JSON\n- [ ] Implement ParseToolCallInfo(toolCallJSON json.RawMessage) — extracts tool type and display args\n- [ ] Implement ParseShellToolResult(toolCallJSON json.RawMessage) — extracts result from completed shellToolCall\n- [ ] Implement Reader(ctx, io.Reader, chan\u003c- AnnotatedEvent, chan\u003c- error)\n- [ ] Reader must: close out channel on EOF/context cancel, send fatal errors on errCh\n- [ ] Handle malformed JSON lines gracefully (log and skip, no panic)\n- [ ] Handle non-JSON lines (the `T: ...` free-plan error lines)\n- [ ] Preserve raw bytes verbatim for every line, including parse failures\n\n## Technical Approach\n- Files to create: internal/events/types.go, internal/events/content.go, internal/events/reader.go, internal/events/reader_test.go, internal/events/content_test.go\n- Use bufio.Scanner for line reading; json.Unmarshal for first-pass parse into RawEvent\n- Scanner.Bytes() strips the trailing newline — correct since WriteEvent re-adds it\n- call_id values can contain literal newlines — handled by json.Unmarshal as long as JSON itself is one-per-line\n- Content types live in a separate file (content.go) to maintain clean separation\n- AssistantMessage.Text is extracted from message.content[0].text via intermediate structs\n- AssistantMessage.IsFinal is true when model_call_id is absent (use json.RawMessage or check for zero value)\n- ToolCallInfo.ToolType is the first key name in the tool_call object (shellToolCall, lsToolCall, etc.)\n- Copy relevant lines from experiments/*.jsonl into internal/events/testdata/ as fixtures\n- Dependencies: task cw-fjr.1 (project scaffold)\n\n## Verification\n- [ ] Unit tests: parse each known event type from real JSONL fixture lines\n- [ ] Unit tests: malformed JSON returns error, doesn't panic\n- [ ] Unit tests: non-JSON line (e.g., \"T: Named models unavailable\") is skipped gracefully\n- [ ] Unit tests: unknown event type parses base envelope successfully\n- [ ] Unit tests: Reader closes out channel on EOF\n- [ ] Unit tests: Reader sends error on errCh for broken pipe\n- [ ] Unit tests: ParseAssistantMessage extracts text, detects final vs mid-turn\n- [ ] Unit tests: ParseToolCallInfo identifies tool type and extracts shell command/timeout\n- [ ] Unit tests: ParseShellToolResult extracts exitCode, stdout, stderr, executionTime\n- [ ] Unit tests: content parse failures return errors (don't panic)\n- [ ] `go vet ./internal/events/...` passes\n\n## Acceptance Criteria\nSubset: AC #6 (raw events preserved with recv_ts), AC #8 (byte-identical proxy — raw bytes must be exact), AC #13 (content types enable text rendering)\n\n## Parallelization\nCan be worked alongside: \"Implement process manager\", \"Implement dual-sink logger\" (after scaffold completes)","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:09:09.795307-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:35:55.953258-06:00","dependencies":[{"issue_id":"cw-fjr.2","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:09:09.795879-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.2","depends_on_id":"cw-fjr.1","type":"blocks","created_at":"2026-02-11T10:12:08.781853-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.3","title":"Implement process manager for cursor-agent lifecycle","description":"## Design Reference\n@docs/design.md#process-manager-internalprocess\n@docs/design.md#prompt-delivery\n@docs/design.md#argument-construction\n@docs/cursor-agent-cli.md#session-resume---resume\n\n## Context\nManages spawning cursor-agent as a child process, delivering the prompt via stdin, and providing Kill/Wait lifecycle methods. This is the boundary between cursor-wrap and the external cursor-agent binary. Supports `--resume \u003csession_id\u003e` for multi-turn sessions.\n\n## Requirements\n- [ ] Define Config struct (AgentBin, Prompt, Model, Workspace, ExtraFlags, Force, SessionID)\n- [ ] Define Session struct (Stdout, Stderr, Cmd)\n- [ ] Implement Start(ctx, Config) that spawns cursor-agent with --print --output-format stream-json\n- [ ] Start() must write prompt to stdin and close stdin before returning\n- [ ] Start() must handle errors during spawn, stdin write, and stdin close (best-effort kill on failure)\n- [ ] Implement buildArgs(Config) to construct the cursor-agent argument list\n- [ ] buildArgs must include --resume \u003csession_id\u003e when Config.SessionID is non-empty\n- [ ] Implement Kill(reason) that sends SIGTERM, waits briefly, then SIGKILL if needed\n- [ ] Implement Wait() that blocks until process exits and returns ProcessState\n\n## Technical Approach\n- Files to create: internal/process/process.go, internal/process/process_test.go\n- Use os/exec.CommandContext for process spawning with context cancellation support\n- buildArgs: always starts with --print --output-format stream-json, then conditionally adds --resume, --force, --model, --workspace, then appends ExtraFlags\n- Kill: send SIGTERM via cmd.Process.Signal, start a short timer (e.g. 5s), then SIGKILL if still running\n- Wait: delegate to cmd.Wait() which returns *os.ProcessState\n- Session does not expose Stdin — it is always written and closed during Start()\n- For tests: spawn simple shell commands (echo, sleep, cat) as stand-ins for cursor-agent\n- Dependencies: task cw-fjr.1 (project scaffold)\n\n## Verification\n- [ ] Unit tests: Start spawns a process and captures stdout (e.g. `echo hello`)\n- [ ] Unit tests: Start writes prompt to stdin (e.g. `cat` reads it back)\n- [ ] Unit tests: Start closes stdin after write (verify child sees EOF)\n- [ ] Unit tests: Kill sends SIGTERM then SIGKILL after deadline (e.g. process that traps SIGTERM)\n- [ ] Unit tests: Wait returns correct exit code\n- [ ] Unit tests: Start returns error for non-existent binary\n- [ ] Unit tests: buildArgs includes --resume when SessionID is set\n- [ ] Unit tests: buildArgs omits --resume when SessionID is empty\n- [ ] `go vet ./internal/process/...` passes\n\n## Acceptance Criteria\nSubset: AC #9 (child process killed cleanly on signal), AC #11 (--resume for multi-turn)\n\n## Parallelization\nCan be worked alongside: \"Implement event types and streaming parser\", \"Implement dual-sink logger\" (after scaffold completes)","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:09:31.074514-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:36:34.776265-06:00","dependencies":[{"issue_id":"cw-fjr.3","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:09:31.075031-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.3","depends_on_id":"cw-fjr.1","type":"blocks","created_at":"2026-02-11T10:12:08.835758-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.4","title":"Implement dual-sink structured logger","description":"## Design Reference\n@docs/design.md#logger-internallogger\n@docs/design.md#log-record-formats\n@docs/design.md#timestamp-serialization\n@docs/logging.md\n\n## Context\nProvides the dual-sink logging infrastructure: a JSONL file sink for forensic replay and a human-readable console sink. Both are slog.Handler implementations. The file sink uses O_SYNC append mode to minimize data loss on crash. Uses a LogSession wrapper type that embeds *slog.Logger and holds the file path for rename on session_id.\n\n## Requirements\n- [ ] Define LogConfig struct (Dir, ConsoleLevel, FileLevel)\n- [ ] Define LogSession struct embedding *slog.Logger with filePath field\n- [ ] Implement Setup(LogConfig) returning (*LogSession, func() error)\n- [ ] Implement SetSessionID(id string) on LogSession — renames log file to include session_id\n- [ ] File sink: writes JSONL, opened with O_APPEND|O_SYNC, timestamps as Unix milliseconds\n- [ ] Console sink: human-readable text format at configurable level\n- [ ] File naming: cursor-wrap-{start_ts}-unknown.jsonl initially, renamed to cursor-wrap-{start_ts}-{session_id}.jsonl by SetSessionID\n- [ ] SetSessionID is no-op if already called or if rename fails (logged at warn)\n- [ ] Teardown function flushes and closes the file sink\n- [ ] Ensure log directory is created if it doesn't exist\n- [ ] Both raw event records and wrapper decision records go through slog (both include time/level/msg fields)\n\n## Technical Approach\n- Files to create: internal/logger/logger.go, internal/logger/logger_test.go\n- LogSession embeds *slog.Logger so callers use standard slog methods (log.Info, log.Debug, etc.)\n- Use slog.NewJSONHandler for the file sink with a custom ReplaceAttr to serialize time as epoch millis\n- Use slog.NewTextHandler for the console sink\n- Combine with a custom multi-handler that fans out to both sinks\n- SetSessionID: uses os.Rename to rename the log file, updates filePath field\n- Default log dir: ~/.cursor-wrap/logs (created with os.MkdirAll)\n- In interactive mode, a single log file spans all turns (session_id is same across --resume turns)\n- Dependencies: task cw-fjr.1 (project scaffold)\n\n## Verification\n- [ ] Unit tests: Setup creates log file in specified directory with placeholder filename\n- [ ] Unit tests: SetSessionID renames the file to include the session_id\n- [ ] Unit tests: JSONL records are valid JSON with time/level/msg plus custom fields\n- [ ] Unit tests: raw event records contain recv_ts and raw fields (validates AC 6)\n- [ ] Unit tests: hang detection records contain all Reason fields: idle_silence_ms, open_call_count, last_event_type, per-call details (validates AC 7)\n- [ ] Unit tests: console output respects level filter\n- [ ] Unit tests: teardown closes the file (subsequent writes fail)\n- [ ] `go vet ./internal/logger/...` passes\n\n## Acceptance Criteria\nSubset: AC #6 (raw events logged with recv_ts), AC #7 (hang decisions logged with full Reason)\n\n## Parallelization\nCan be worked alongside: \"Implement event types and streaming parser\", \"Implement process manager\" (after scaffold completes)","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:09:48.372499-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:36:58.054055-06:00","dependencies":[{"issue_id":"cw-fjr.4","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:09:48.373048-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.4","depends_on_id":"cw-fjr.1","type":"blocks","created_at":"2026-02-11T10:12:08.88964-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.5","title":"Implement hang detection monitor state machine","description":"## Design Reference\n@docs/design.md#hang-monitor-internalmonitor\n@docs/design.md#decision-logic-in-checktimeout\n@docs/design.md#default-thresholds\n@docs/hang-detection.md\n\n## Context\nThe core hang detection logic. A state machine that consumes events.AnnotatedEvents, tracks open tool calls, and produces verdicts (OK, Waiting, Hang) on timer ticks. This is the most complex and most critical component — incorrect logic means either false positives (killing good sessions) or missed hangs.\n\n## Requirements\n- [ ] Define State struct (OpenCalls map, LastEventAt, SessionDone, SessionID)\n- [ ] Define OpenToolCall struct (CallID, ModelCallID, StartedAt, TimeoutMS, Command)\n- [ ] Define Verdict enum (VerdictOK, VerdictWaiting, VerdictHang)\n- [ ] Define Reason struct (IdleSilenceMS, OpenCallCount, LastEventType, OpenCalls []OpenCallDetail)\n- [ ] Define OpenCallDetail struct (CallID, Command, ElapsedMS, TimeoutMS)\n- [ ] Implement Reason.String() method for diagnostic output\n- [ ] Implement Monitor struct with injectable clock, idleTimeout, toolGrace\n- [ ] Implement NewMonitor(idleTimeout, toolGrace, ...Option) with WithClock option\n- [ ] Implement ProcessEvent(events.AnnotatedEvent) — update state, track open calls, set SessionDone on result\n- [ ] Implement CheckTimeout(now) — per-tool deadline logic, allExpired hang detection\n- [ ] Implement Now(), SessionDone(), and SessionID() accessors\n- [ ] ProcessEvent must: add to OpenCalls on tool_call/started, remove on tool_call/completed, update LastEventAt on every event, set SessionDone on result event, extract ShellToolArgs for timeout/command, capture SessionID from system/init\n- [ ] CheckTimeout must: return VerdictOK if SessionDone, VerdictHang if no open calls and idle \u003e idleTimeout, VerdictHang only when ALL open tools exceed their individual deadline, VerdictWaiting otherwise\n\n## Technical Approach\n- Files to create: internal/monitor/monitor.go, internal/monitor/monitor_test.go\n- The monitor imports internal/events for events.AnnotatedEvent and event type structs\n- Per-tool deadline: toolElapsed = now - tool.StartedAt; toolDeadline = tool.TimeoutMS + toolGrace; if tool.TimeoutMS == 0, use idleTimeout as fallback\n- Hang only when ALL open tools have expired — not just one\n- Reason.String() formats one-line summaries like: \"idle 65000ms, 0 open calls, last event: thinking\"\n- SessionID() returns the session_id captured from the system/init event (used by session loop for --resume)\n- fakeClock test helper: struct with Now field and Advance method\n- Test helper functions: thinkingCompletedEvent(), toolCallStartedEvent(t, callID, timeoutMS), toolCallCompletedEvent(t, callID), resultEvent(), systemInitEvent(sessionID)\n- Dependencies: task cw-fjr.2 (event types — needs events.AnnotatedEvent, RawEvent)\n\n## Verification\n- [ ] Unit tests: sequential tool call (started → silence → completed → no hang)\n- [ ] Unit tests: parallel tool calls (two started → one completed → still waiting → second completed → no hang)\n- [ ] Unit tests: idle hang (thinking/completed → long silence with no open tools → VerdictHang)\n- [ ] Unit tests: tool timeout hang (tool started → silence exceeds tool.TimeoutMS + grace → VerdictHang)\n- [ ] Unit tests: partial expiry (tool A expired, tool B still within deadline → VerdictWaiting, not Hang)\n- [ ] Unit tests: normal completion (result event → VerdictOK regardless of subsequent silence)\n- [ ] Unit tests: non-shell tool with no timeout (falls back to idleTimeout)\n- [ ] Unit tests: unknown event type still resets LastEventAt\n- [ ] Unit tests: unmatched tool_call/completed (call_id not in OpenCalls) doesn't panic\n- [ ] Unit tests: SessionID() returns id from system/init event\n- [ ] Unit tests: Reason.String() produces human-readable summary\n- [ ] All tests use fakeClock, no real time.Sleep\n- [ ] `go vet ./internal/monitor/...` passes\n\n## Acceptance Criteria\nSubset: AC #2 (idle hang detection), AC #3 (tool-timeout hang detection), AC #4 (no false-positive on long tool), AC #5 (no false-positive on parallel tools)","status":"open","priority":0,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:10:19.363462-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:37:40.810793-06:00","dependencies":[{"issue_id":"cw-fjr.5","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:10:19.364383-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.5","depends_on_id":"cw-fjr.2","type":"blocks","created_at":"2026-02-11T10:12:08.943461-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.6","title":"Implement orchestrator event loop and helper functions","description":"## Design Reference\n@docs/design.md#orchestrator-in-cmdcursor-wrapmain.go\n@docs/design.md#per-turn-event-loop\n@docs/design.md#session-loop\n@docs/design.md#prompt-reading\n@docs/design.md#orchestrator-helpers\n@docs/design.md#signal-handling\n\n## Context\nThe orchestrator has two layers: a session loop (run) that manages multi-turn interactive sessions, and a per-turn event loop (runTurn) that processes one cursor-agent invocation. The session loop manages prompt input, --resume for subsequent turns, and hang recovery in interactive mode. The per-turn loop spawns the process, reads events, feeds the formatter and monitor, and detects hangs.\n\n## Requirements\n- [ ] Define ErrHangDetected and ErrAbnormalExit sentinel errors\n- [ ] Define TurnResult struct (SessionID, Err, Reason)\n- [ ] Implement runTurn(ctx, procCfg, fmtr, log, cfg) TurnResult — per-turn event loop\n- [ ] runTurn: launch Reader goroutine and drainStderr goroutine with sync.WaitGroup\n- [ ] runTurn: full select loop over eventCh, readerErrCh, ticker.C, ctx.Done()\n- [ ] runTurn: call fmtr.WriteEvent(ev) for each event (replaces forwardToStdout)\n- [ ] runTurn: call fmtr.Flush() after event loop exits\n- [ ] runTurn: on hang, early-return TurnResult with Reason populated\n- [ ] runTurn: create fresh Monitor per turn (no stale state between turns)\n- [ ] Implement run(ctx, cfg) error — session loop\n- [ ] run: call logger.Setup, format.New, firstPrompt\n- [ ] run: loop over turns, setting procCfg.SessionID for --resume on subsequent turns\n- [ ] run: call log.SetSessionID after first system/init\n- [ ] run: in interactive mode, call fmtr.WriteHangIndicator on hang then continue to next prompt\n- [ ] run: in -p mode, exit on any error\n- [ ] run: non-recoverable errors (spawn failure, reader error, abnormal exit) exit even in interactive mode\n- [ ] run: clean exit on stdin EOF / Ctrl+D\n- [ ] Implement firstPrompt(cfg) — positional arg \u003e stdin, with TTY check for -p mode\n- [ ] Implement readPrompt(r) — loop reading non-empty lines, show \"\u003e \" on TTY, skip blanks\n- [ ] Implement handleStreamEnd, drainStderr, logRawEvent, logVerdict, reasonAttrs helpers\n- [ ] All helpers accept *logger.LogSession (not *slog.Logger)\n- [ ] Implement main() with signal.NotifyContext for SIGINT/SIGTERM\n- [ ] Exit codes: 0 = normal, 1 = error, 2 = hang detected\n- [ ] Defer teardown with error logging: defer func() { if err := teardown(); ... }()\n- [ ] ExtraFlags slice aliasing safety comment in session loop\n\n## Technical Approach\n- Files to modify: cmd/cursor-wrap/main.go (replace placeholder from scaffold task)\n- The Config struct aggregates process.Config, logger.LogConfig, monitor thresholds, Print bool, OutputFormat string, PositionalPrompt string, PromptReader *bufio.Reader\n- Session loop creates a value copy of process.Config per turn, setting Prompt and SessionID\n- firstPrompt: if -p with TTY stdin and no positional arg, return error\n- readPrompt: for loop (not recursion), calls isTerminal(os.Stdin) for prompt indicator\n- logRawEvent uses log.Debug with \"raw_event\" msg, recv_ts, and slog.Any(\"raw\", json.RawMessage)\n- format.New creates the formatter based on cfg.OutputFormat\n- Dependencies: cw-fjr.2 (events), cw-fjr.3 (process), cw-fjr.4 (logger), cw-fjr.5 (monitor), cw-5p3 (format)\n\n## Verification\n- [ ] Unit tests: logRawEvent produces valid JSONL with recv_ts and raw fields\n- [ ] Unit tests: reasonAttrs returns correct slog key-value pairs\n- [ ] Unit tests: handleStreamEnd returns nil when SessionDone is true\n- [ ] Unit tests: handleStreamEnd returns ErrAbnormalExit when SessionDone is false\n- [ ] Unit tests: firstPrompt returns positional arg when provided\n- [ ] Unit tests: firstPrompt returns error for -p with TTY and no positional arg\n- [ ] Unit tests: firstPrompt reads stdin to EOF for -p with piped stdin\n- [ ] Unit tests: readPrompt skips blank lines, returns first non-empty line\n- [ ] Unit tests: readPrompt returns io.EOF when input exhausted\n- [ ] go build ./cmd/cursor-wrap compiles successfully\n- [ ] go vet ./... passes\n\n## Acceptance Criteria\nSubset: AC #1 (normal exit 0), AC #6 (raw events logged), AC #7 (hang decisions logged), AC #8 (byte-identical stdout via formatter), AC #9 (clean kill on signal), AC #11 (interactive resume), AC #12 (hang recovery in interactive mode), AC #14 (-p single turn)","status":"open","priority":0,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:10:46.363562-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:40:09.456095-06:00","dependencies":[{"issue_id":"cw-fjr.6","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:10:46.364089-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.6","depends_on_id":"cw-fjr.2","type":"blocks","created_at":"2026-02-11T10:12:09.000806-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.6","depends_on_id":"cw-fjr.3","type":"blocks","created_at":"2026-02-11T10:12:09.053452-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.6","depends_on_id":"cw-fjr.4","type":"blocks","created_at":"2026-02-11T10:12:09.106501-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.6","depends_on_id":"cw-fjr.5","type":"blocks","created_at":"2026-02-11T10:12:09.159831-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.6","depends_on_id":"cw-5p3","type":"blocks","created_at":"2026-02-11T12:40:14.402853-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.7","title":"Implement CLI flag parsing and Config construction","description":"## Design Reference\n@docs/design.md#cli-flags-cmdcursor-wrap\n@docs/design.md#prompt-resolution\n@docs/design.md#config-struct\n@docs/design.md#helper-functions\n\n## Context\nParses command-line flags for cursor-wrap, constructs the unified Config struct that the orchestrator needs, and handles the -- separator for pass-through cursor-agent flags. Uses stdlib flag package per coding standards. Includes the new -p/--print flag and --output-format with mode-dependent defaults.\n\n## Requirements\n- [ ] Define top-level Config struct matching design: Print, OutputFormat, IdleTimeout, ToolGrace, TickInterval, Log (LogConfig), Process (process.Config), PositionalPrompt, PromptReader\n- [ ] Implement parseFlags(args []string) Config\n- [ ] Flags: -p/--print (default false), --output-format (default: stream-json with -p, text without)\n- [ ] Flags: --idle-timeout (default 60s), --tool-grace (default 30s), --tick-interval (default 5s)\n- [ ] Flags: --log-dir (default ~/.cursor-wrap/logs), --log-level (default: info with -p, warn without)\n- [ ] Flags: --agent-bin (default: from PATH), --model (default auto), --workspace, --force (default true)\n- [ ] Handle -- separator: everything after -- goes into ExtraFlags\n- [ ] Handle positional prompt: last non-flag argument after -- handling\n- [ ] Apply mode-dependent defaults after flag parsing based on -p\n- [ ] Map --log-level string to slog.Level\n- [ ] Implement isTerminal(f *os.File) bool using golang.org/x/term.IsTerminal or syscall\n- [ ] Initialize PromptReader as bufio.NewReader(os.Stdin)\n\n## Technical Approach\n- Files to create: cmd/cursor-wrap/config.go, cmd/cursor-wrap/config_test.go\n- Use stdlib flag package (no third-party CLI libraries per coding standards)\n- For -- handling: use flag.Args() after flag.Parse(), scan for \"--\" separator\n- For agent-bin default: use exec.LookPath(\"cursor-agent\")\n- For log-dir default: use os.UserHomeDir() + \"/.cursor-wrap/logs\"\n- Mode-dependent defaults: after parsing, if -p not set, default OutputFormat to \"text\" and ConsoleLevel to warn; if -p set, default OutputFormat to \"stream-json\" and ConsoleLevel to info\n- isTerminal: use golang.org/x/term.IsTerminal(int(f.Fd())) — this is the only third-party dep\n- Dependencies: task cw-fjr.6 (orchestrator — needs the Config struct definition); in practice these are co-developed\n\n## Verification\n- [ ] Unit tests: default values are correct for -p mode\n- [ ] Unit tests: default values are correct for interactive mode\n- [ ] Unit tests: all flags are parsed correctly\n- [ ] Unit tests: -- separator correctly splits wrapper flags from cursor-agent flags\n- [ ] Unit tests: --log-level maps strings to slog.Level correctly\n- [ ] Unit tests: positional prompt is captured correctly\n- [ ] Unit tests: --output-format explicit value overrides mode default\n- [ ] go vet ./cmd/cursor-wrap/... passes\n\n## Acceptance Criteria\nSubset: AC #10 (all thresholds configurable via CLI flags), AC #14 (-p flag behavior)\n\n## Parallelization\nDeveloped alongside cw-fjr.6 (orchestrator) since Config struct is shared.","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:11:00.836503-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:40:38.2958-06:00","dependencies":[{"issue_id":"cw-fjr.7","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:11:00.837017-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.7","depends_on_id":"cw-fjr.6","type":"blocks","created_at":"2026-02-11T10:12:09.213187-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.8","title":"Implement integration tests for full wrapper pipeline","description":"## Design Reference\n@docs/design.md#integration-tests\n@docs/design.md#acceptance-criteria\n\n## Context\nIntegration tests verify the full pipeline end-to-end using synthetic JSONL and fake child processes (not real cursor-agent). These tests exercise the interaction between all packages: process spawning, event reading, monitor state transitions, logging, formatter output, and orchestrator control flow — including multi-turn sessions with --resume.\n\n## Requirements\n- [ ] Test normal completion: spawn a helper process that emits a complete event sequence (system/init → user → thinking → assistant → tool_call/started → tool_call/completed → result), verify wrapper exits 0\n- [ ] Test idle hang detection: spawn a helper that emits some events then goes silent (no open tools), verify wrapper detects hang within expected window and exits with code 2\n- [ ] Test tool-timeout hang: spawn a helper that emits tool_call/started then goes silent past the tool timeout + grace, verify hang detected\n- [ ] Test transparent proxy (stream-json): capture wrapper stdout with -p --output-format stream-json and verify byte-identical to synthetic JSONL\n- [ ] Test text format: capture wrapper stdout with --output-format text and verify human-readable rendering (assistant text, tool call spinners/checks)\n- [ ] Test multi-turn: feed two complete event sequences (simulating two turns), verify the wrapper reads a second prompt and passes --resume with the correct session_id\n- [ ] Test hang recovery in interactive mode: first turn hangs, verify hang indicator is displayed, wrapper prompts for next input instead of exiting\n- [ ] Test log file output: verify log file contains raw event records with recv_ts and wrapper decision records\n- [ ] Test signal handling: send SIGINT to wrapper process, verify child is killed and wrapper exits\n\n## Technical Approach\n- Files to create: integration_test.go (in project root or cmd/cursor-wrap/)\n- Use a Go test helper binary (TestMain or exec a small Go program) that writes synthetic JSONL to stdout and optionally hangs\n- Alternative: use a shell script that echos JSONL lines with sleep delays\n- Build cursor-wrap binary with go build, then exec it in tests\n- Use short timeouts (e.g. idle-timeout=2s, tool-grace=1s, tick-interval=500ms) for fast tests\n- For multi-turn tests: feed prompts via stdin pipe, verify --resume appears in child process args\n- Capture stdout and stderr from the wrapper process for assertions\n- Read log file after test to verify log content\n- Dependencies: all implementation tasks (cw-fjr.1 through cw-fjr.7 and cw-5p3)\n\n## Verification\n- [ ] All integration test scenarios pass\n- [ ] Tests complete within reasonable time (\u003c 30s total, using short timeouts)\n- [ ] No flaky tests from timing issues (use generous margins)\n- [ ] go test -v -run Integration ./... passes\n\n## Acceptance Criteria\nSubset: AC #1 (normal exit), AC #2 (idle hang), AC #3 (tool-timeout hang), AC #6 (log content), AC #8 (transparent proxy), AC #9 (signal handling), AC #11 (interactive resume), AC #12 (hang recovery), AC #13 (text format), AC #14 (-p behavior)","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:11:25.336784-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:41:16.975182-06:00","dependencies":[{"issue_id":"cw-fjr.8","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:11:25.337357-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.8","depends_on_id":"cw-fjr.6","type":"blocks","created_at":"2026-02-11T10:12:09.271035-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.8","depends_on_id":"cw-fjr.7","type":"blocks","created_at":"2026-02-11T10:12:09.326086-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.9","title":"Implement end-to-end smoke test with real cursor-agent","description":"## Design Reference\n@docs/design.md#end-to-end-tests\n\n## Context\nEnd-to-end tests run cursor-wrap against a real cursor-agent invocation to verify the full system works in production conditions. These are slower, require network/API access, and are run manually or in CI with appropriate credentials.\n\n## Requirements\n- [ ] Test basic prompt: run cursor-wrap -p with a simple prompt (e.g. \"say hi\"), verify stdout contains expected event stream and process exits cleanly (exit 0)\n- [ ] Test text format: run cursor-wrap -p --output-format text with a simple prompt, verify human-readable output\n- [ ] Test two-turn interactive session: first turn with positional arg, second turn via stdin pipe, verify --resume is used on the second invocation\n- [ ] Test that log file is created with raw events and wrapper decisions\n- [ ] Document how to run E2E tests (requires cursor-agent authentication)\n- [ ] Guard E2E tests behind a build tag or environment variable (e.g. -tags=e2e or CURSOR_E2E=1)\n\n## Technical Approach\n- Files to create: e2e_test.go (in project root, guarded by build tag)\n- Invoke cursor-wrap binary with: echo \"say hi\" | cursor-wrap -p --idle-timeout=60s\n- Compare wrapper stdout structure to expected event lifecycle (system/init → ... → result)\n- Don't assert on content (model output varies), assert on event structure\n- For multi-turn: use a small Go test that writes prompts to cursor-wrap's stdin pipe and reads stdout\n- Dependencies: all implementation tasks + integration tests (cw-fjr.1 through cw-fjr.8 and cw-5p3)\n\n## Verification\n- [ ] E2E test passes when run manually with active cursor-agent credentials\n- [ ] E2E test is skipped by default (not run in normal go test)\n- [ ] Test produces clear error message if cursor-agent is not available\n- [ ] Multi-turn test verifies session_id is preserved across turns\n\n## Acceptance Criteria\nSubset: AC #1 (normal completion), AC #8 (transparent proxy with real agent), AC #11 (interactive resume with real agent), AC #13 (text format with real agent)\n\n## Parallelization\nCannot be parallelized — depends on all other tasks completing first.","status":"open","priority":2,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:11:39.076329-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T12:41:32.707898-06:00","dependencies":[{"issue_id":"cw-fjr.9","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:11:39.076905-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.9","depends_on_id":"cw-fjr.8","type":"blocks","created_at":"2026-02-11T10:12:09.408754-06:00","created_by":"Travis Brown"}]}
