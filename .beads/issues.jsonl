{"id":"cw-fjr","title":"cursor-agent hang detection wrapper","description":"## Design Document\n@docs/design.md\n\n## Overview\nBuild a Go CLI wrapper (`cursor-wrap`) around the `cursor-agent` CLI that transparently proxies stream-json output, detects hangs by analyzing event flow patterns in real time, takes corrective action (kill + optional restart) on confirmed hang, and produces structured logs sufficient for post-mortem analysis.\n\n## Packages\n- `cmd/cursor-wrap/` — CLI entry point, flag parsing, orchestrator event loop\n- `internal/events/` — JSON event types and streaming parser\n- `internal/monitor/` — Hang detection state machine\n- `internal/process/` — Child process spawn, kill, wait\n- `internal/logger/` — Dual-sink structured logging (JSONL file + console)\n\n## Acceptance Criteria\n1. Wrapper exits 0 when cursor-agent completes normally (result event received)\n2. Wrapper detects an idle hang (no events, no open tools) within idleTimeout + tickInterval and exits non-zero\n3. Wrapper detects a tool-timeout hang (tool exceeds declared timeout + grace) within toolGrace + tickInterval and exits non-zero\n4. Wrapper does NOT false-positive on a long-running tool call that is within its declared timeout\n5. Wrapper does NOT false-positive on parallel tool calls where one finishes before others\n6. Every raw cursor-agent event appears in the log file with a recv_ts\n7. Every hang detection decision appears in the log file with the full Reason struct\n8. Wrapper's stdout is byte-identical to cursor-agent's stdout (transparent proxy)\n9. On SIGINT/SIGTERM to the wrapper, the child process is killed cleanly\n10. All thresholds are configurable via CLI flags","status":"open","priority":0,"issue_type":"epic","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:08:13.774782-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T10:08:13.774782-06:00"}
{"id":"cw-fjr.1","title":"Initialize Go module and project directory structure","description":"## Design Reference\n@docs/design.md#architecture\n@docs/coding-standards.md#project-layout\n\n## Context\nFoundation task. Creates the Go module and directory skeleton that all other tasks build on. No business logic — just the structural scaffolding.\n\n## Requirements\n- [ ] Create go.mod with appropriate module path\n- [ ] Create directory structure: cmd/cursor-wrap/, internal/events/, internal/monitor/, internal/process/, internal/logger/\n- [ ] Create minimal main.go placeholder in cmd/cursor-wrap/\n- [ ] Update .gitignore for Go binary artifacts\n- [ ] Verify `go build ./...` succeeds\n\n## Technical Approach\n- Module path: a short local path like `cursor-wrap` (no remote import path needed per coding standards — everything is internal)\n- Go version: 1.25 (matches local toolchain)\n- main.go: minimal placeholder that compiles, e.g. prints version and exits\n- Files to create: go.mod, cmd/cursor-wrap/main.go\n- Directories to create: internal/events/, internal/monitor/, internal/process/, internal/logger/\n- Dependencies: none (first task)\n\n## Verification\n- [ ] `go build ./cmd/cursor-wrap` compiles without errors\n- [ ] `go vet ./...` passes\n- [ ] Directory structure matches coding-standards.md layout\n\n## Acceptance Criteria\nSubset: none directly — this is scaffolding that enables all other acceptance criteria.\n\n## Parallelization\nNo dependencies. This must complete before all other tasks.","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:08:43.488711-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T10:08:43.488711-06:00","dependencies":[{"issue_id":"cw-fjr.1","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:08:43.48934-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.2","title":"Implement event types and streaming parser","description":"## Design Reference\n@docs/design.md#data-model\n@docs/design.md#event-reader-internalevents\n@docs/stream-json-events.md\n\n## Context\nDefines the Go types for all cursor-agent stream-json events and implements the streaming Reader that parses stdout line-by-line into typed AnnotatedEvents. This is consumed by both the monitor (for hang detection) and the orchestrator (for logging and forwarding).\n\n## Requirements\n- [ ] Define RawEvent struct with Type, Subtype, Line fields\n- [ ] Define AnnotatedEvent struct wrapping RawEvent with RecvTime and Raw bytes\n- [ ] Define SystemInit, ToolCallStarted, ToolCallCompleted, Result structs\n- [ ] Define ShellToolArgs struct for extracting timeout/command from shellToolCall\n- [ ] Implement Reader(ctx, io.Reader, chan\u003c- AnnotatedEvent, chan\u003c- error)\n- [ ] Reader must: close out channel on EOF/context cancel, send fatal errors on errCh\n- [ ] Handle malformed JSON lines gracefully (log and skip, no panic)\n- [ ] Handle non-JSON lines (the `T: ...` free-plan error lines)\n- [ ] Preserve raw bytes verbatim for every line, including parse failures\n\n## Technical Approach\n- Files to create: internal/events/types.go, internal/events/reader.go, internal/events/reader_test.go\n- Use bufio.Scanner for line reading; json.Unmarshal for first-pass parse into RawEvent\n- Scanner.Bytes() strips the trailing newline — this is correct since forwardToStdout re-adds it\n- call_id values can contain literal newlines — since we parse JSON (not split on newlines), this is handled by json.Unmarshal naturally as long as the JSON itself is one-per-line from cursor-agent\n- Copy relevant lines from experiments/*.jsonl into internal/events/testdata/ as fixtures\n- Dependencies: task cw-fjr.1 (project scaffold)\n\n## Verification\n- [ ] Unit tests: parse each known event type from real JSONL fixture lines\n- [ ] Unit tests: malformed JSON returns error, doesn't panic\n- [ ] Unit tests: non-JSON line (e.g., \"T: Named models unavailable\") is skipped gracefully\n- [ ] Unit tests: unknown event type parses base envelope successfully\n- [ ] Unit tests: Reader closes out channel on EOF\n- [ ] Unit tests: Reader sends error on errCh for broken pipe\n- [ ] `go vet ./internal/events/...` passes\n\n## Acceptance Criteria\nSubset: AC #6 (raw events preserved with recv_ts), AC #8 (byte-identical proxy — raw bytes must be exact)\n\n## Parallelization\nCan be worked alongside: \"Implement process manager\", \"Implement dual-sink logger\" (after scaffold completes)","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:09:09.795307-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T10:09:09.795307-06:00","dependencies":[{"issue_id":"cw-fjr.2","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:09:09.795879-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.2","depends_on_id":"cw-fjr.1","type":"blocks","created_at":"2026-02-11T10:12:08.781853-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.3","title":"Implement process manager for cursor-agent lifecycle","description":"## Design Reference\n@docs/design.md#process-manager-internalprocess\n@docs/design.md#prompt-delivery\n\n## Context\nManages spawning cursor-agent as a child process, delivering the prompt via stdin, and providing Kill/Wait lifecycle methods. This is the boundary between cursor-wrap and the external cursor-agent binary.\n\n## Requirements\n- [ ] Define Config struct (AgentBin, Prompt, Model, Workspace, ExtraFlags, Force)\n- [ ] Define Session struct (Stdout, Stderr, Cmd)\n- [ ] Implement Start(ctx, Config) that spawns cursor-agent with --print --output-format stream-json\n- [ ] Start() must write prompt to stdin and close stdin before returning\n- [ ] Start() must handle errors during spawn, stdin write, and stdin close (best-effort kill on failure)\n- [ ] Implement buildArgs(Config) to construct the cursor-agent argument list\n- [ ] Implement Kill(reason) that sends SIGTERM, waits briefly, then SIGKILL if needed\n- [ ] Implement Wait() that blocks until process exits and returns ProcessState\n\n## Technical Approach\n- Files to create: internal/process/process.go, internal/process/process_test.go\n- Use os/exec.CommandContext for process spawning with context cancellation support\n- Kill: send SIGTERM via cmd.Process.Signal, start a short timer (e.g. 5s), then SIGKILL if still running\n- Wait: delegate to cmd.Wait() which returns *os.ProcessState\n- For tests: spawn simple shell commands (echo, sleep, cat) as stand-ins for cursor-agent\n- Dependencies: task cw-fjr.1 (project scaffold)\n\n## Verification\n- [ ] Unit tests: Start spawns a process and captures stdout (e.g. `echo hello`)\n- [ ] Unit tests: Start writes prompt to stdin (e.g. `cat` reads it back)\n- [ ] Unit tests: Start closes stdin after write (verify child sees EOF)\n- [ ] Unit tests: Kill sends SIGTERM then SIGKILL after deadline (e.g. process that traps SIGTERM)\n- [ ] Unit tests: Wait returns correct exit code\n- [ ] Unit tests: Start returns error for non-existent binary\n- [ ] `go vet ./internal/process/...` passes\n\n## Acceptance Criteria\nSubset: AC #9 (child process killed cleanly on signal)\n\n## Parallelization\nCan be worked alongside: \"Implement event types and streaming parser\", \"Implement dual-sink logger\" (after scaffold completes)","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:09:31.074514-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T10:09:31.074514-06:00","dependencies":[{"issue_id":"cw-fjr.3","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:09:31.075031-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.3","depends_on_id":"cw-fjr.1","type":"blocks","created_at":"2026-02-11T10:12:08.835758-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.4","title":"Implement dual-sink structured logger","description":"## Design Reference\n@docs/design.md#logger-internallogger\n@docs/design.md#log-record-formats\n@docs/design.md#timestamp-serialization\n@docs/logging.md\n\n## Context\nProvides the dual-sink logging infrastructure: a JSONL file sink for forensic replay and a human-readable console sink. Both are slog.Handler implementations. The file sink uses O_SYNC append mode to minimize data loss on crash.\n\n## Requirements\n- [ ] Define LogConfig struct (Dir, SessionID, ConsoleLevel, FileLevel)\n- [ ] Implement Setup(LogConfig) returning (*slog.Logger, func() error)\n- [ ] File sink: writes JSONL, opened with O_APPEND|O_SYNC, timestamps as Unix milliseconds\n- [ ] Console sink: human-readable text format at configurable level\n- [ ] File naming: cursor-wrap-{start_ts}-{session_id}.jsonl\n- [ ] Handle pre-session_id state: start with placeholder name, rename when session_id arrives\n- [ ] Teardown function flushes and closes the file sink\n- [ ] Ensure log directory is created if it doesn't exist\n\n## Technical Approach\n- Files to create: internal/logger/logger.go, internal/logger/logger_test.go\n- Use slog.NewJSONHandler for the file sink with a custom ReplaceAttr to serialize time as epoch millis\n- Use slog.NewTextHandler for the console sink\n- Combine with a custom multi-handler that fans out to both sinks\n- The file rename on session_id: provide a SetSessionID(string) method on a wrapper type, or return a rename callback from Setup\n- Default log dir: ~/.cursor-wrap/logs (created with os.MkdirAll)\n- Dependencies: task cw-fjr.1 (project scaffold)\n\n## Verification\n- [ ] Unit tests: Setup creates log file in specified directory\n- [ ] Unit tests: JSONL records are valid JSON with expected fields\n- [ ] Unit tests: timestamps are Unix milliseconds (int64), not RFC3339\n- [ ] Unit tests: console output respects level filter\n- [ ] Unit tests: teardown closes the file (subsequent writes fail)\n- [ ] Unit tests: file rename works when session_id is provided after setup\n- [ ] `go vet ./internal/logger/...` passes\n\n## Acceptance Criteria\nSubset: AC #6 (raw events logged with recv_ts), AC #7 (hang decisions logged with full Reason)\n\n## Parallelization\nCan be worked alongside: \"Implement event types and streaming parser\", \"Implement process manager\" (after scaffold completes)","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:09:48.372499-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T10:09:48.372499-06:00","dependencies":[{"issue_id":"cw-fjr.4","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:09:48.373048-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.4","depends_on_id":"cw-fjr.1","type":"blocks","created_at":"2026-02-11T10:12:08.88964-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.5","title":"Implement hang detection monitor state machine","description":"## Design Reference\n@docs/design.md#hang-monitor-internalmonitor\n@docs/design.md#decision-logic-in-checktimeout\n@docs/design.md#default-thresholds\n@docs/hang-detection.md\n\n## Context\nThe core hang detection logic. A state machine that consumes AnnotatedEvents, tracks open tool calls, and produces verdicts (OK, Waiting, Hang) on timer ticks. This is the most complex and most critical component — incorrect logic means either false positives (killing good sessions) or missed hangs.\n\n## Requirements\n- [ ] Define State struct (OpenCalls map, LastEventAt, SessionDone, SessionID)\n- [ ] Define OpenToolCall struct (CallID, ModelCallID, StartedAt, TimeoutMS, Command)\n- [ ] Define Verdict enum (VerdictOK, VerdictWaiting, VerdictHang)\n- [ ] Define Reason struct (IdleSilenceMS, OpenCallCount, LastEventType, OpenCalls []OpenCallDetail)\n- [ ] Define OpenCallDetail struct (CallID, Command, ElapsedMS, TimeoutMS)\n- [ ] Implement Reason.String() method for diagnostic output\n- [ ] Implement Monitor struct with injectable clock, idleTimeout, toolGrace\n- [ ] Implement NewMonitor(idleTimeout, toolGrace, ...Option) with WithClock option\n- [ ] Implement ProcessEvent(AnnotatedEvent) — update state, track open calls, set SessionDone on result\n- [ ] Implement CheckTimeout(now) — per-tool deadline logic, allExpired hang detection\n- [ ] Implement Now() and SessionDone() accessors\n- [ ] ProcessEvent must: add to OpenCalls on tool_call/started, remove on tool_call/completed, update LastEventAt on every event, set SessionDone on result event, extract ShellToolArgs for timeout/command\n- [ ] CheckTimeout must: return VerdictOK if SessionDone, VerdictHang if no open calls and idle \u003e idleTimeout, VerdictHang only when ALL open tools exceed their individual deadline, VerdictWaiting otherwise\n\n## Technical Approach\n- Files to create: internal/monitor/monitor.go, internal/monitor/monitor_test.go\n- The monitor imports internal/events for AnnotatedEvent and event type constants\n- Per-tool deadline: toolElapsed = now - tool.StartedAt; toolDeadline = tool.TimeoutMS + toolGrace; if tool.TimeoutMS == 0, use idleTimeout as fallback\n- Hang only when ALL open tools have expired — not just one\n- fakeClock test helper: struct with Now field and Advance method\n- Test helper functions: thinkingCompletedEvent(), toolCallStartedEvent(t, callID, timeoutMS), toolCallCompletedEvent(t, callID), resultEvent()\n- Dependencies: task cw-fjr.2 (event types — needs AnnotatedEvent, RawEvent)\n\n## Verification\n- [ ] Unit tests: sequential tool call (started → silence → completed → no hang)\n- [ ] Unit tests: parallel tool calls (two started → one completed → still waiting → second completed → no hang)\n- [ ] Unit tests: idle hang (thinking/completed → long silence with no open tools → VerdictHang)\n- [ ] Unit tests: tool timeout hang (tool started → silence exceeds tool.TimeoutMS + grace → VerdictHang)\n- [ ] Unit tests: partial expiry (tool A expired, tool B still within deadline → VerdictWaiting, not Hang)\n- [ ] Unit tests: normal completion (result event → VerdictOK regardless of subsequent silence)\n- [ ] Unit tests: non-shell tool with no timeout (falls back to idleTimeout)\n- [ ] Unit tests: unknown event type still resets LastEventAt\n- [ ] Unit tests: unmatched tool_call/completed (call_id not in OpenCalls) doesn't panic\n- [ ] All tests use fakeClock, no real time.Sleep\n- [ ] `go vet ./internal/monitor/...` passes\n\n## Acceptance Criteria\nSubset: AC #2 (idle hang detection), AC #3 (tool-timeout hang detection), AC #4 (no false-positive on long tool), AC #5 (no false-positive on parallel tools)","status":"open","priority":0,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:10:19.363462-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T10:10:19.363462-06:00","dependencies":[{"issue_id":"cw-fjr.5","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:10:19.364383-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.5","depends_on_id":"cw-fjr.2","type":"blocks","created_at":"2026-02-11T10:12:08.943461-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.6","title":"Implement orchestrator event loop and helper functions","description":"## Design Reference\n@docs/design.md#orchestrator-in-cmdcursor-wrapmain.go\n@docs/design.md#orchestrator-helpers\n@docs/design.md#signal-handling\n\n## Context\nThe orchestrator is the central event loop that wires all packages together. It spawns the process, launches the reader and stderr drainer as goroutines, runs the ticker for hang checks, and handles all exit paths (normal, hang, error, signal). This is where the select loop, WaitGroup, and signal handling live.\n\n## Requirements\n- [ ] Define ErrHangDetected and ErrAbnormalExit sentinel errors\n- [ ] Implement run(ctx, Config) with the full select loop: eventCh, readerErrCh, ticker, ctx.Done\n- [ ] Launch Reader goroutine and drainStderr goroutine with sync.WaitGroup\n- [ ] Implement handleStreamEnd(sess, mon, log) — Wait for process, check SessionDone, return appropriate error\n- [ ] Implement drainStderr(ctx, r, log) — scan stderr lines, check context in loop, log at debug\n- [ ] Implement logRawEvent(log, ev) — write forensic replay record with recv_ts + raw JSON\n- [ ] Implement forwardToStdout(raw) — write raw bytes + newline to os.Stdout\n- [ ] Implement logVerdict(log, verdict, ev) — log VerdictWaiting at debug, skip VerdictOK\n- [ ] Implement reasonAttrs(reason) — convert Reason to slog key-value pairs\n- [ ] On hang: kill process, return ErrHangDetected\n- [ ] On context cancel: kill process, return ctx.Err()\n- [ ] On reader error: kill process, return kill error\n- [ ] wg.Wait() before returning (ensures goroutines finish before teardown)\n- [ ] Implement main() with signal.NotifyContext for SIGINT/SIGTERM\n- [ ] Exit codes: 0 = normal, 1 = error, 2 = hang detected\n\n## Technical Approach\n- Files to modify: cmd/cursor-wrap/main.go (replace placeholder from scaffold task)\n- The Config struct aggregates process.Config, logger.LogConfig, and monitor thresholds (IdleTimeout, ToolGrace, TickInterval)\n- main() calls signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)\n- main() calls parseFlags() then run(ctx, cfg)\n- main() checks errors.Is(err, ErrHangDetected) for exit code 2\n- logRawEvent uses slog.Debug with \"raw\" key containing json.RawMessage\n- forwardToStdout uses os.Stdout.Write (not fmt.Println — no formatting)\n- Dependencies: tasks cw-fjr.2 (events), cw-fjr.3 (process), cw-fjr.4 (logger), cw-fjr.5 (monitor)\n\n## Verification\n- [ ] Unit tests: logRawEvent produces valid JSONL with recv_ts and raw fields\n- [ ] Unit tests: forwardToStdout writes raw bytes + newline\n- [ ] Unit tests: reasonAttrs returns correct slog key-value pairs\n- [ ] Unit tests: handleStreamEnd returns nil when SessionDone is true\n- [ ] Unit tests: handleStreamEnd returns ErrAbnormalExit when SessionDone is false\n- [ ] `go build ./cmd/cursor-wrap` compiles successfully\n- [ ] `go vet ./...` passes\n\n## Acceptance Criteria\nSubset: AC #1 (normal exit 0), AC #6 (raw events logged), AC #7 (hang decisions logged), AC #8 (byte-identical stdout), AC #9 (clean kill on signal)","status":"open","priority":0,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:10:46.363562-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T10:10:46.363562-06:00","dependencies":[{"issue_id":"cw-fjr.6","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:10:46.364089-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.6","depends_on_id":"cw-fjr.2","type":"blocks","created_at":"2026-02-11T10:12:09.000806-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.6","depends_on_id":"cw-fjr.3","type":"blocks","created_at":"2026-02-11T10:12:09.053452-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.6","depends_on_id":"cw-fjr.4","type":"blocks","created_at":"2026-02-11T10:12:09.106501-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.6","depends_on_id":"cw-fjr.5","type":"blocks","created_at":"2026-02-11T10:12:09.159831-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.7","title":"Implement CLI flag parsing and Config construction","description":"## Design Reference\n@docs/design.md#cli-flags-cmdcursor-wrap\n\n## Context\nParses command-line flags for cursor-wrap, constructs the unified Config struct that the orchestrator needs, and handles the -- separator for pass-through cursor-agent flags. Uses stdlib flag package per coding standards.\n\n## Requirements\n- [ ] Define top-level Config struct aggregating process.Config, logger.LogConfig, IdleTimeout, ToolGrace, TickInterval\n- [ ] Implement parseFlags() Config that parses all CLI flags\n- [ ] Flags: --idle-timeout (default 60s), --tool-grace (default 30s), --tick-interval (default 5s)\n- [ ] Flags: --log-dir (default ~/.cursor-wrap/logs), --log-level (default info)\n- [ ] Flags: --agent-bin (default: look up cursor-agent in PATH), --model (default auto), --workspace, --force (default true)\n- [ ] Handle -- separator: everything after -- goes into ExtraFlags\n- [ ] Handle prompt: remaining positional arg after flag parsing, or read from stdin if no arg\n- [ ] Validate required fields (prompt must be non-empty)\n- [ ] Map --log-level string to slog.Level\n\n## Technical Approach\n- Files to create: cmd/cursor-wrap/config.go, cmd/cursor-wrap/config_test.go\n- Use stdlib flag package (no third-party CLI libraries per coding standards)\n- For -- handling: use flag.Args() after flag.Parse(), scan for \"--\" separator\n- For agent-bin default: use exec.LookPath(\"cursor-agent\")\n- For log-dir default: use os.UserHomeDir() + \"/.cursor-wrap/logs\"\n- Dependencies: task cw-fjr.6 (orchestrator — needs the Config struct definition)\n\n## Verification\n- [ ] Unit tests: default values are correct\n- [ ] Unit tests: all flags are parsed correctly\n- [ ] Unit tests: -- separator correctly splits wrapper flags from cursor-agent flags\n- [ ] Unit tests: --log-level maps strings to slog.Level correctly\n- [ ] Unit tests: missing prompt returns error\n- [ ] `go vet ./cmd/cursor-wrap/...` passes\n\n## Acceptance Criteria\nSubset: AC #10 (all thresholds configurable via CLI flags)","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:11:00.836503-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T10:11:00.836503-06:00","dependencies":[{"issue_id":"cw-fjr.7","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:11:00.837017-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.7","depends_on_id":"cw-fjr.6","type":"blocks","created_at":"2026-02-11T10:12:09.213187-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.8","title":"Implement integration tests for full wrapper pipeline","description":"## Design Reference\n@docs/design.md#integration-tests\n@docs/design.md#acceptance-criteria\n\n## Context\nIntegration tests verify the full pipeline end-to-end using synthetic JSONL and fake child processes (not real cursor-agent). These tests exercise the interaction between all packages: process spawning, event reading, monitor state transitions, logging, and orchestrator control flow.\n\n## Requirements\n- [ ] Test normal completion: spawn a helper process that emits a complete event sequence (system/init → user → thinking → assistant → tool_call/started → tool_call/completed → result), verify wrapper exits 0\n- [ ] Test idle hang detection: spawn a helper that emits some events then goes silent (no open tools), verify wrapper detects hang within expected window and exits with code 2\n- [ ] Test tool-timeout hang: spawn a helper that emits tool_call/started then goes silent past the tool timeout + grace, verify hang detected\n- [ ] Test transparent proxy: capture wrapper stdout and verify it is byte-identical to the synthetic JSONL the helper emitted\n- [ ] Test log file output: verify log file contains raw event records with recv_ts and wrapper decision records\n- [ ] Test signal handling: send SIGINT to wrapper process, verify child is killed and wrapper exits\n\n## Technical Approach\n- Files to create: integration_test.go (in project root or cmd/cursor-wrap/)\n- Use a Go test helper binary (TestMain or exec a small Go program) that writes synthetic JSONL to stdout and optionally hangs\n- Alternative: use a shell script that echos JSONL lines with sleep delays\n- Build cursor-wrap binary with `go build`, then exec it in tests\n- Use short timeouts (e.g. idle-timeout=2s, tool-grace=1s, tick-interval=500ms) for fast tests\n- Capture stdout and stderr from the wrapper process for assertions\n- Read log file after test to verify log content\n- Dependencies: all implementation tasks (cw-fjr.1 through cw-fjr.7)\n\n## Verification\n- [ ] All integration test scenarios pass\n- [ ] Tests complete within reasonable time (\u003c 30s total, using short timeouts)\n- [ ] No flaky tests from timing issues (use generous margins)\n- [ ] `go test -v -run Integration ./...` passes\n\n## Acceptance Criteria\nSubset: AC #1 (normal exit), AC #2 (idle hang), AC #3 (tool-timeout hang), AC #6 (log content), AC #8 (transparent proxy), AC #9 (signal handling)","status":"open","priority":1,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:11:25.336784-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T10:11:25.336784-06:00","dependencies":[{"issue_id":"cw-fjr.8","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:11:25.337357-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.8","depends_on_id":"cw-fjr.6","type":"blocks","created_at":"2026-02-11T10:12:09.271035-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.8","depends_on_id":"cw-fjr.7","type":"blocks","created_at":"2026-02-11T10:12:09.326086-06:00","created_by":"Travis Brown"}]}
{"id":"cw-fjr.9","title":"Implement end-to-end smoke test with real cursor-agent","description":"## Design Reference\n@docs/design.md#end-to-end-tests\n\n## Context\nEnd-to-end tests run cursor-wrap against a real cursor-agent invocation to verify the full system works in production conditions. These are slower, require network/API access, and are run manually or in CI with appropriate credentials.\n\n## Requirements\n- [ ] Test basic prompt: run cursor-wrap with a simple prompt (e.g. \"say hi\"), verify stdout contains expected event stream and process exits cleanly (exit 0)\n- [ ] Test that log file is created with raw events and wrapper decisions\n- [ ] Test that wrapper stdout matches what cursor-agent would emit directly\n- [ ] Document how to run E2E tests (requires cursor-agent authentication)\n- [ ] Guard E2E tests behind a build tag or environment variable (e.g. -tags=e2e or CURSOR_E2E=1)\n\n## Technical Approach\n- Files to create: e2e_test.go (in project root, guarded by build tag)\n- Invoke cursor-wrap binary with: echo \"say hi\" | cursor-wrap --idle-timeout=60s\n- Compare wrapper stdout structure to expected event lifecycle (system/init → ... → result)\n- Don't assert on content (model output varies), assert on event structure\n- Dependencies: all implementation tasks + integration tests (cw-fjr.1 through cw-fjr.8)\n\n## Verification\n- [ ] E2E test passes when run manually with active cursor-agent credentials\n- [ ] E2E test is skipped by default (not run in normal `go test`)\n- [ ] Test produces clear error message if cursor-agent is not available\n\n## Acceptance Criteria\nSubset: AC #1 (normal completion), AC #8 (transparent proxy with real agent)\n\n## Parallelization\nCannot be parallelized — depends on all other tasks completing first.","status":"open","priority":2,"issue_type":"task","owner":"4742936+reifying@users.noreply.github.com","created_at":"2026-02-11T10:11:39.076329-06:00","created_by":"Travis Brown","updated_at":"2026-02-11T10:11:39.076329-06:00","dependencies":[{"issue_id":"cw-fjr.9","depends_on_id":"cw-fjr","type":"parent-child","created_at":"2026-02-11T10:11:39.076905-06:00","created_by":"Travis Brown"},{"issue_id":"cw-fjr.9","depends_on_id":"cw-fjr.8","type":"blocks","created_at":"2026-02-11T10:12:09.408754-06:00","created_by":"Travis Brown"}]}
